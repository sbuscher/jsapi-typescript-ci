import { b5 as e, e1 as n, r, a6 as q$2, eO as u, gn as p, eS as r$1, go as A$1, A as n$1, J as r$2, q as f, t, L as c$1, gp as g$2, eY as x$1, fc as t$1, $ as e$1, a1 as n$2 } from '../index.js';
import { v as v$2, l, d as d$1 } from './lineSegment.c80cb9d8.js';
import { d, q as q$1, j as j$2, k as k$2, E as E$2, X, _, Q } from './sphere.cd3303e0.js';
import { E as E$3 } from './QueryEngineResult.a743b456.js';
import { s as s$1 } from './vectorStacks.4201351c.js';
import { c } from './Util.64796755.js';
import { extractComponentsEdgeLocationsLayout as y$2 } from './EdgeProcessingWorker.91a49e81.js';
import './quantizationUtils.c974b9d1.js';
import './WhereClause.76454a7e.js';
import './utils.93eac933.js';
import './ClassBreaksDefinition.c69658e0.js';
import './projectionSupport.ca1e9e3d.js';
import './json.dcc9ce98.js';
import './utils.5a452461.js';
import './quatf64.c1e27511.js';
import './mat4f64.490cb75d.js';
import './deduplicate.4ee46abc.js';
import './InterleavedLayout.13315fe2.js';
import './BufferView.d9eb8b2c.js';
import './types.81573e1f.js';
import './VertexAttribute.33243f22.js';
import './enums.f11416db.js';
import './VertexElementDescriptor.e016eb10.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
function s(r){return r?{ray:d(r.ray),c0:r.c0,c1:r.c1}:{ray:d(),c0:0,c1:Number.MAX_VALUE}}new s$1((()=>({c0:0,c1:0,ray:null})));

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
var tt;!function(t){t[t.NONE=0]="NONE",t[t.CLAMP=1]="CLAMP",t[t.INFINITE_MIN=4]="INFINITE_MIN",t[t.INFINITE_MAX=8]="INFINITE_MAX";}(tt||(tt={}));tt.INFINITE_MIN|tt.INFINITE_MAX;tt.INFINITE_MAX;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
function P$1(T,_){for(let O=0;O<g$1.NUM;O++){const R=T[O];if(R[0]*_[0]+R[1]*_[1]+R[2]*_[2]+R[3]>=_[3])return !1}return !0}var k$1,v$1;!function(T){T[T.LEFT=0]="LEFT",T[T.RIGHT=1]="RIGHT",T[T.BOTTOM=2]="BOTTOM",T[T.TOP=3]="TOP",T[T.NEAR=4]="NEAR",T[T.FAR=5]="FAR";}(k$1||(k$1={})),function(T){T[T.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",T[T.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",T[T.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",T[T.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",T[T.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",T[T.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",T[T.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",T[T.FAR_TOP_LEFT=7]="FAR_TOP_LEFT";}(v$1||(v$1={}));({bottom:[v$1.FAR_BOTTOM_RIGHT,v$1.NEAR_BOTTOM_RIGHT,v$1.NEAR_BOTTOM_LEFT,v$1.FAR_BOTTOM_LEFT],near:[v$1.NEAR_BOTTOM_LEFT,v$1.NEAR_BOTTOM_RIGHT,v$1.NEAR_TOP_RIGHT,v$1.NEAR_TOP_LEFT],far:[v$1.FAR_BOTTOM_RIGHT,v$1.FAR_BOTTOM_LEFT,v$1.FAR_TOP_LEFT,v$1.FAR_TOP_RIGHT],right:[v$1.NEAR_BOTTOM_RIGHT,v$1.FAR_BOTTOM_RIGHT,v$1.FAR_TOP_RIGHT,v$1.NEAR_TOP_RIGHT],left:[v$1.FAR_BOTTOM_LEFT,v$1.NEAR_BOTTOM_LEFT,v$1.NEAR_TOP_LEFT,v$1.FAR_TOP_LEFT],top:[v$1.FAR_TOP_LEFT,v$1.NEAR_TOP_LEFT,v$1.NEAR_TOP_RIGHT,v$1.FAR_TOP_RIGHT]});var g$1,b;!function(T){T[T.NUM=6]="NUM";}(g$1||(g$1={})),function(T){T[T.NUM=8]="NUM";}(b||(b={}));new s$1(s);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
class g{constructor(e,t){this._objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new O,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth));}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),O.clearPool(),B[0]=null,w.prune(),W.prune();}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=O.acquire();for(let o=0;o<t;o++){const t=e[o];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n));}O.release(n);}remove(t,n=null){this._objectCount-=t.length;const o=O.acquire();for(const s of t){const t=r(n)?n:q$1(this._objectToBoundingSphere(s),C$1);z(t[3])?(o.init(this._root),this._remove(s,t,o)):this._degenerateObjects.delete(s);}O.release(o),this._shrink();}update(e,t){if(!z(t[3])&&this._isDegenerate(e))return;const n=R(e);this.remove(n,t),this.add(n);}forEachAlongRay(e,t,n){const o=j$2(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(o,e))return !1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(o,e)&&n(e);})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(o,e)&&n(e);})),!0}));}forEachAlongRayWithVerticalOffset(e,t,n,o){const s=j$2(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(s,e,o))return !1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(s,e,o)&&n(e);})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(s,e,o)&&n(e);})),!0}));}forEach(e){this._forEachNode(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e);}forEachDegenerateObject(e){this._degenerateObjects.forEach(e);}findClosest(e,t,n,r=(()=>!0),i=1/0){let h=1/0,a=1/0,d=null;const c=E$1(e,t),u$1=o=>{if(--i,!r(o))return;const s=this._objectToBoundingSphere(o);if(!P$1(n,s))return;const c=M(e,t,E$2(s)),u=c-s[3],f=c+s[3];u<h&&(h=u,a=f,d=o);};return this._forEachNodeDepthOrdered(this._root,(r=>{if(i<=0||!P$1(n,r.bounds))return !1;q$2(F,c,r.halfSize),u(F,F,r.bounds);if(M(e,t,F)>a)return !1;const h=r.node;return h.terminals.forAll((e=>u$1(e))),null!==h.residents&&h.residents.forAll((e=>u$1(e))),!0}),e,t),d}forEachInDepthRange(e,t,n,r,i,h,a){let d=-1/0,c=1/0;const u$1={setRange:e=>{n===g.DepthOrder.FRONT_TO_BACK?(d=Math.max(d,e.near),c=Math.min(c,e.far)):(d=Math.max(d,-e.far),c=Math.min(c,-e.near));}};u$1.setRange(r);const f=M(t,n,e),m=E$1(t,n),p=E$1(t,-n),b=e=>{if(!a(e))return;const o=this._objectToBoundingSphere(e),s=E$2(o),r=M(t,n,s)-f,m=r-o[3],p=r+o[3];m>c||p<d||!P$1(h,o)||i(e,u$1);};this._forEachNodeDepthOrdered(this._root,(e=>{if(!P$1(h,e.bounds))return !1;q$2(F,m,e.halfSize),u(F,F,e.bounds);if(M(t,n,F)-f>c)return !1;q$2(F,p,e.halfSize),u(F,F,e.bounds);if(M(t,n,F)-f<d)return !1;const r=e.node;return r.terminals.forAll((e=>b(e))),null!==r.residents&&r.residents.forAll((e=>b(e))),!0}),t,n);}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.bounds,t.halfSize)));}forEachNeighbor(e,t){const n=k$2(t),o=E$2(t),s=t=>{const s=this._objectToBoundingSphere(t),i=k$2(s),h=n+i;p(E$2(s),o)-h*h<=0&&e(t);};this._forEachNode(this._root,(e=>{const t=k$2(e.bounds),i=n+t;if(p(E$2(e.bounds),o)-i*i>0)return !1;const h=e.node;return h.terminals.forAll((e=>s(e))),null!==h.residents&&h.residents.forAll((e=>s(e))),!0})),this.forEachDegenerateObject(s);}_intersectsNode(e,t){return x(t.bounds,2*-t.halfSize,k),x(t.bounds,2*t.halfSize,q),c(e.origin,e.direction,k,q)}_intersectsNodeWithOffset(e,t,n){return x(t.bounds,2*-t.halfSize,k),x(t.bounds,2*t.halfSize,q),n.applyToMinMax(k,q),c(e.origin,e.direction,k,q)}_intersectsObject(e,t){const n=this._objectToBoundingSphere(t);return !(n[3]>0)||X(n,e)}_intersectsObjectWithOffset(e,t,n){const o=this._objectToBoundingSphere(t);return !(o[3]>0)||X(n.applyToBoundingSphere(o),e)}_forEachNode(e,t){let n=O.acquire().init(e);const o=[n];for(;0!==o.length;){if(n=o.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++){n.node.children[e]&&o.push(O.acquire().init(n).advance(e));}O.release(n);}}_forEachNodeDepthOrdered(e,t,n,o=g.DepthOrder.FRONT_TO_BACK){let s=O.acquire().init(e);const r=[s];for(T(n,o,V);0!==r.length;){if(s=r.pop(),t(s)&&!s.isLeaf())for(let e=7;e>=0;--e){const t=V[e];s.node.children[t]&&r.push(O.acquire().init(s).advance(t));}O.release(s);}}_remove(e,t,n){w.clear();const o=n.advanceTo(t,((e,t)=>{w.push(e.node),w.push(t);}))?n.node.terminals:n.node.residents;if(o.removeUnordered(e),0===o.length)for(let s=w.length-2;s>=0;s-=2){const e=w.data[s],t=w.data[s+1];if(!this._purge(e,t))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return !1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return !1;return !0}_purge(e,t){return t>=0&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new n({shrink:!0})),!0)}_add(e,t){t.advanceTo(this._objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t));}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const o=O.acquire().init(e);this._add(t.getItemAt(n),o),O.release(o);}}_grow(e,t){if(0!==t&&(N(e,t,(e=>this._objectToBoundingSphere(e)),I),z(I[3])&&!this._fitsInsideTree(I)))if(this._nodeIsEmpty(this._root.node))q$1(I,this._root.bounds),this._root.halfSize=1.25*I[3];else {const e=this._rootBoundsForRootAsSubNode(I);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(I,e):this._growRootAsSubNode(e),O.release(e);}}_rebuildTree(e,t){r$1(P,t.bounds),P[3]=t.halfSize,N([e,P],2,(e=>e),L);const n=O.acquire().init(this._root);this._root.initFrom(null,L,1.25*L[3]),this._forEachNode(n,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),O.release(n);}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let o=-1/0;const s=this._root.bounds,r=this._root.halfSize;for(let i=0;i<3;i++){const e=s[i]-r-(n[i]-t),h=n[i]+t-(s[i]+r),a=Math.max(0,Math.ceil(e/(2*r))),d=Math.max(0,Math.ceil(h/(2*r)))+1,l=2**Math.ceil(Math.log(a+d)*Math.LOG2E);o=Math.max(o,l),K[i].min=a,K[i].max=d;}for(let i=0;i<3;i++){let e=K[i].min,t=K[i].max;const n=(o-(e+t))/2;e+=Math.ceil(n),t+=Math.floor(n);const h=s[i]-r-e*r*2;y$1[i]=h+(t+e)*r;}return y$1[3]=o*r*v,O.acquire().initFrom(null,y$1,o*r,0)}_growRootAsSubNode(e){const t=this._root.node;r$1(I,this._root.bounds),I[3]=this._root.halfSize,this._root.init(e),e.advanceTo(I,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals;}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0;}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return -1;let e=null;const t=this._root.node.children;let n=0,o=0;for(;o<t.length&&null==e;)n=o++,e=t[n];for(;o<t.length;)if(t[o++])return -1;return n}_isDegenerate(e){return !z(this._objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}}class O{constructor(){this.bounds=_(),this.halfSize=0,this.initFrom(null,null,0,0);}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(t,n,o,s=this.depth){return this.node=r(t)?t:O.createEmptyNode(),r(n)&&q$1(n,this.bounds),this.halfSize=o,this.depth=s,this}advance(e){let t=this.node.children[e];t||(t=O.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=A[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*v,this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null;}const o=this._childIndex(e);t&&t(this,o),this.advance(o);}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return (t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return {children:[null,null,null,null,null,null,null,null],terminals:new n({shrink:!0}),residents:new n({shrink:!0})}}static acquire(){return O._pool.acquire()}static release(e){O._pool.release(e);}static clearPool(){O._pool.prune();}}function j$1(e,t){e[0]=Math.min(e[0],t[0]-t[3]),e[1]=Math.min(e[1],t[1]-t[3]),e[2]=Math.min(e[2],t[2]-t[3]);}function S(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3]);}function x(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t;}function N(e,t,n,o){if(1===t){const t=n(e[0]);q$1(t,o);}else {k[0]=1/0,k[1]=1/0,k[2]=1/0,q[0]=-1/0,q[1]=-1/0,q[2]=-1/0;for(let o=0;o<t;o++){const t=n(e[o]);z(t[3])&&(j$1(k,t),S(q,t));}A$1(o,k,q,.5),o[3]=Math.max(q[0]-k[0],q[1]-k[1],q[2]-k[2])/2;}}function T(e,t,n){if(!W.length)for(let o=0;o<8;++o)W.push({index:0,distance:0});for(let o=0;o<8;++o){const n=A[o];W.data[o].index=o,W.data[o].distance=M(e,t,n);}W.sort(((e,t)=>e.distance-t.distance));for(let o=0;o<8;++o)n[o]=W.data[o].index;}function E$1(e,t){let n=1/0,o=null;for(let s=0;s<8;++s){const r=M(e,t,D[s]);r<n&&(n=r,o=D[s]);}return o}function M(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function z(e){return !isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}O._pool=new e(O),function(e){var t;(t=e.DepthOrder||(e.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT";}(g||(g={}));const A=[r$2(-1,-1,-1),r$2(1,-1,-1),r$2(-1,1,-1),r$2(1,1,-1),r$2(-1,-1,1),r$2(1,-1,1),r$2(-1,1,1),r$2(1,1,1)],D=[r$2(-1,-1,-1),r$2(-1,-1,1),r$2(-1,1,-1),r$2(-1,1,1),r$2(1,-1,-1),r$2(1,-1,1),r$2(1,1,-1),r$2(1,1,1)],v=Math.sqrt(3),B=[null];function R(e){return B[0]=e,B}const y$1=_(),F=n$1(),k=n$1(),q=n$1(),w=new n,C$1=_(),I=_(),P=_(),L=_(),K=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],W=new n,V=[0,0,0,0,0,0,0,0],G=g;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
let j=class{constructor(){this._idToComponent=new Map,this._components=new G((e=>e.bounds)),this._edges=new G((e=>e.bounds)),this._tmpLineSegment=v$2(),this._tmpP1=n$1(),this._tmpP2=n$1(),this._tmpP3=n$1(),this.remoteClient=null;}async fetchCandidates(e,t){await Promise.resolve(),f(t),await this._ensureEdgeLocations(e,t);const s=[];return this._edges.forEachNeighbor((t=>this._addCandidates(e,t,s)),e.bounds),{result:{candidates:s}}}async _ensureEdgeLocations(e,o){const n=[];if(this._components.forEachNeighbor((e=>{if(t(e.info)){const{id:t,uid:s}=e;n.push({id:t,uid:s});}}),e.bounds),!n.length)return;const i={components:n},r=await this.remoteClient.invoke("fetchAllEdgeLocations",i,c$1(o,{}));for(const t of r.components)this._setFetchEdgeLocations(t);}async add(e){const t=new C(e.id,e.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(e){const t=this._idToComponent.get(e.id);if(t){const e=[];this._edges.forEachNeighbor((s=>{s.component===t&&e.push(s);}),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id);}return {result:{}}}_setFetchEdgeLocations(e){const s=this._idToComponent.get(e.id);if(t(s)||e.uid!==s.uid)return;const o=y$2.createView(e.locations),n=new Array(o.count),a=n$1(),p=n$1();for(let t=0;t<o.count;t++){const c=_(),u$1=E$2(c);o.position0.getVec(t,a),o.position1.getVec(t,p),g$2(u$1,u$1,a,.5),g$2(u$1,u$1,p,.5),u(u$1,u$1,e.origin),c[3]=x$1(u$1,a);const m=new E(s,t,c);n[t]=m;}this._edges.add(n);const{objectIds:u$1,origin:m}=e;s.info={locations:o,objectIds:u$1,origin:m};}_addCandidates(e,t,s){const{locations:o,origin:n,objectIds:i}=t.component.info,d=o.position0.getVec(t.index,this._tmpP1),c=o.position1.getVec(t.index,this._tmpP2);u(d,d,n),u(c,c,n);const a=i[o.componentIndex.get(t.index)];this._addEdgeCandidate(e,a,d,c,s),this._addVertexCandidate(e,a,d,s),this._addVertexCandidate(e,a,c,s);}_addEdgeCandidate(e,t,s,o,n){if(!(e.types&E$3.EDGE))return;const i=E$2(e.bounds),r=l(s,o,this._tmpLineSegment),c=d$1(r,i,this._tmpP3);if(!Q(e.bounds,c))return null;n.push({type:"edge",objectId:t,target:t$1(c),distance:x$1(i,c),start:t$1(s),end:t$1(o)});}_addVertexCandidate(e,t,s,o){if(!(e.types&E$3.VERTEX))return;const n=E$2(e.bounds);if(!Q(e.bounds,s))return null;o.push({type:"vertex",objectId:t,target:t$1(s),distance:x$1(n,s)});}};function y(){return new j}j=e$1([n$2("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],j);class C{constructor(e,t){this.id=e,this.bounds=t,this.info=null,this.uid=++C.uid;}}C.uid=0;class E{constructor(e,t,s){this.component=e,this.index=t,this.bounds=s;}}

export { j as SceneLayerSnappingSourceWorker, y as default };
//# sourceMappingURL=SceneLayerSnappingSourceWorker.cf866ca1.js.map
